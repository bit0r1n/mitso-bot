import { Markup, Telegraf } from 'telegraf'
import * as mongoose from 'mongoose'
import { SuperDuperUpgradedContext } from './helpers/context'
import { User, UserState } from './schemas/User'
import { CallbackIdSplitter, batchButtons, callbackIdBuild, dateToCallback, keyboards } from './helpers/keyboards'
import { Parser } from './parser/api'
import { Keeper } from './keeper/api'
import { callbackQuery, message } from 'telegraf/filters'
import { getWeekStart, lessonsToMessage, weekToHuman } from './keeper/helpers'
import { Group } from './parser/interfaces'

['BOT_TOKEN', 'MONGO_URL', 'PARSER_URL', 'KEEPER_URL'].every(key => {
  if (!process.env[key])
    throw new Error(`${key} is not set`)
})

await mongoose.connect(process.env.MONGO_URL!)

const bot = new Telegraf<SuperDuperUpgradedContext>(process.env.BOT_TOKEN!)
const parser = new Parser(process.env.PARSER_URL!)
const keeper = new Keeper(process.env.KEEPER_URL!)

bot.use(async (ctx, next) => {
  if (!ctx.from) return

  let chatId = ctx.from.id
  let user = await User.findOne({ telegramId: chatId })

  if (!user) {
    user = await User.create({
      telegramId: chatId,
      username: ctx.from.username,
      state: UserState.AskingGroup
    })
    ctx.newUser = true
  }

  ctx.user = user

  return next()
})

bot.start(async ctx => {
  if (ctx.newUser) {
    await ctx.reply('üçâ –ü—Ä–∏–≤–µ—Ç, —è –º–æ–≥—É —Ç–µ–±–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ!\n–¢–æ–ª—å–∫–æ –º–Ω–µ –¥–ª—è —ç—Ç–æ–≥–æ –Ω—É–∂–Ω–æ –∑–Ω–∞—Ç—å —Ç–≤–æ—é –≥—Ä—É–ø–ø—É üò´')
    await ctx.reply('ü§® –î–∞–≤–∞–π –Ω–∞–π–¥–µ–º —Ç–≤–æ—é –≥—Ä—É–ø–ø—É. –ù–∞–ø–∏—à–∏ –µ—ë –Ω–æ–º–µ—Ä')
    return
  }

  if (ctx.user.state === UserState.MainMenu) {
    await ctx.reply('üçâ –•–≤–∞—Ç–∞–π –º–µ–Ω—é', {
      reply_markup: keyboards[ctx.user.state].resize().reply_markup
    })
  } else if (ctx.user.state === UserState.AskingGroup) {
    await ctx.reply('üçÜ –ü–æ–≥–æ–¥–∏, —è –ø–æ–∫–∞ –∂–¥—É –æ—Ç —Ç–µ–±—è –Ω–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã', {
      reply_markup: keyboards[ctx.user.state].resize().reply_markup
    })
  } else if (ctx.user.state === UserState.ChoosingGroup) {
    await ctx.reply('üëû –í—ã–±–µ—Ä–∏ –≥—Ä—É–ø–ø—É', {
      reply_markup: batchButtons(
        ctx.user.choosing_groups
          .map(g => Markup.button.callback(
            g.display!,
            callbackIdBuild('select_group', [ g.id! ])
          ))
      ).reply_markup
    })
  }
})

bot.hears(/^–∏–¥–∏|–ø–æ—à(–µ|—ë)–ª –Ω–∞—Ö—É–π/i, async (ctx) => {
  await ctx.reply('—Å–∞–º –∏–¥–∏') // @krosbite
})

bot.hears([ '–°–µ–≥–æ–¥–Ω—è', '–ó–∞–≤—Ç—Ä–∞' ], async (ctx) => {
  if (ctx.user.state !== UserState.MainMenu) return

  const extraTime = ctx.message.text === '–ó–∞–≤—Ç—Ä–∞' ? 24 * 60 ** 2 * 1e3 : 0

  const todayStart = new Date()
  todayStart.setTime(todayStart.getTime() + (3 * 60 ** 2 * 1e3) + extraTime)
  todayStart.setHours(0, 0, 0, 0)

  const tomorrowStart = new Date()
  tomorrowStart.setTime(tomorrowStart.getTime() + (3 * 60 ** 2 * 1e3) + extraTime)
  tomorrowStart.setHours(0, 0, 0, 0)
  tomorrowStart.setDate(tomorrowStart.getDate() + 1)

  const lessons = await keeper.getLessons({
    group: ctx.user.group!.id,
    from: todayStart,
    before: tomorrowStart
  })

  if (!lessons.length) {
    await ctx.reply(`ü§© –ù–∞ ${ctx.message.text.toLowerCase()} –Ω–µ—Ç –∑–∞–Ω—è—Ç–∏–π`)
    return
  }
  await ctx.reply([
    `–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ ${ctx.user.group!.display} –Ω–∞ ${ctx.message.text.toLowerCase()}`,
    lessonsToMessage(lessons)
  ].join('\n'))
})

bot.hears('–ù–µ–¥–µ–ª—è', async (ctx) => {
  if (ctx.user.state !== UserState.MainMenu) return

  const weeks = await keeper.getWeeks({
    group: ctx.user.group!.id!,
    from: new Date()
  })

  const buttons = batchButtons(
    weeks.map((week, i) =>
      Markup.button.callback(
        weekToHuman(week),
        callbackIdBuild('week', [ `${i}`, dateToCallback(week) ])
      )),
    3,
    // [ [ Markup.button.callback('üöΩ –ê—Ä—Ö–∏–≤ –Ω–µ–¥–µ–ª—å', callbackIdBuild('week', [ 'archive' ])) ] ]
  )

  await ctx.reply('üß¶ –í—ã–±–µ—Ä–∏ –Ω–µ–¥–µ–ª—é', {
    reply_markup: buttons.reply_markup
  })
})

bot.hears('–°–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É', async (ctx) => {
  if (ctx.user.state !== UserState.MainMenu) return

  ctx.user.state = UserState.AskingGroup
  // @ts-ignore
  await ctx.user.save()

  await ctx.reply('üë° –í–≤–µ–¥–∏ –Ω–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã', {
    reply_markup: Markup.removeKeyboard().reply_markup
  })
})

bot.hears('–î—Ä—É–≥–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è', async (ctx) => {
  if (ctx.user.state !== UserState.MainMenu) return

  await ctx.reply('ü•æ –í—ã–±–µ—Ä–∏ –∫–∞–∫–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ —Ç–µ–±–µ –Ω—É–∂–Ω–æ', {
    parse_mode: 'MarkdownV2',
    reply_markup: Markup.inlineKeyboard([
      [ Markup.button.callback('–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å', callbackIdBuild('teacher_week')), Markup.button.callback('–ì—Ä—É–ø–ø–∞', callbackIdBuild('group_week')) ]
    ]).reply_markup
  })
})

bot.hears('–û—Ç–º–µ–Ω–∞', async (ctx) => {
  if (ctx.user.state === UserState.ChoosingGroup) {
    if (!ctx.user.group || !Object.values(ctx.user.group).filter(Boolean).length) {
      await ctx.reply('üò≥ –ù–µ–µ, –±–µ–∑ –≥—Ä—É–ø–ø—ã –º—ã –Ω–µ –Ω–∞—á–∏–Ω–∞–µ–º')
    } else {
      ctx.user.state = UserState.MainMenu
      // @ts-ignore
      await ctx.user.save()

      await ctx.reply('ü´† –ª–∞–¥–Ω', {
        reply_markup: keyboards[ctx.user.state as UserState].resize().reply_markup
      })
    }
  } else if ([ UserState.AskingWeekTeacher, UserState.AskingWeekGroup ].includes(ctx.user.state)) {
    ctx.user.state = UserState.MainMenu
    // @ts-ignore
    await ctx.user.save()

    await ctx.reply('üëç (–æ–∫ (üëç))', {
      reply_markup: keyboards[ctx.user.state as UserState].resize().reply_markup
    })
  }
})

bot.on(callbackQuery('data'), async (ctx) => {
  const [ command, ...args ] = ctx.callbackQuery.data.split(CallbackIdSplitter)

  if (command === 'select_group') {
    const group = ctx.user.choosing_groups.find(g => g.id === args[0])
    if (!group) {
      ctx.user.choosing_groups = []
      ctx.user.state = UserState.AskingGroup
      // @ts-ignore
      await ctx.user.save()

      await ctx.reply('üòµ‚Äçüí´ –ö–∞–∂–µ—Ç—Å—è –ø—Ä–æ–∏–∑–æ—à–ª–∞ –∫–∞–∫–∞—è-—Ç–æ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ –≥—Ä—É–ø–ø—ã. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∏—Å–∫–∞—Ç—å –Ω–æ–≤—É—é –≥—Ä—É–ø–ø—É, –æ—Ç–ø—Ä–∞–≤–∏–≤ –µ—ë –Ω–æ–º–µ—Ä')
      return
    }

    ctx.user.group = { id: group.id, display: group.display }
    ctx.user.state = UserState.MainMenu
    // @ts-ignore
    await ctx.user.save()

    await ctx.deleteMessage().catch(() => {})

    await ctx.replyWithMarkdownV2(`ü´î –í—ã–±—Ä–∞–Ω–∞ –≥—Ä—É–ø–ø–∞ *${group.display}*`, {
      reply_markup: keyboards[ctx.user.state as UserState].resize().reply_markup
    })
    return
  } else if (command === 'week') {
    const [ weekId, weekStartRaw, groupId ] = args

    if (weekId === 'archive') {
      // TODO: weeks -> view archive
      await ctx.answerCbQuery()
      return
    }

    const weekStart = new Date(weekStartRaw)
    const weekEnd = new Date(weekStartRaw)
    weekEnd.setDate(weekEnd.getDate() + 7)

    if (groupId) {
      try {
        await parser.getGroup(groupId)
      } catch (e) {
        await ctx.answerCbQuery()
        await ctx.editMessageText(
          (e as Error).message === 'Group not found'
            ? 'ü•≤ –ì—Ä—É–ø–ø–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'
            : 'ü§Ø –ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫–∞–∫–∞—è-—Ç–æ –æ—à–∏–±–∫–∞'
          )
        return
      }
    }

    const lessons = await keeper.getLessons({
      group: groupId || ctx.user.group!.id,
      from: weekStart,
      before: weekEnd
    })

    const target = weekId === '0' ? '—Ç–µ–∫—É—â—É—é –Ω–µ–¥–µ–ª—é' : `${+weekId + 1} –Ω–µ–¥–µ–ª—é`

    if (!lessons.length) {
      await ctx.answerCbQuery()
      await ctx.editMessageText(`ü§Ø –†–∞—Å–ø–∏–∞–Ω–∏—è –Ω–∞ ${target} –Ω–µ—Ç—É`)
      return
    }

    await ctx.answerCbQuery()
    await ctx.editMessageText([
      `–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ ${ctx.user.group!.display} –Ω–∞ ${target}`,
      lessonsToMessage(lessons)
    ].join('\n'))
  } else if (command === 'teacher_week') {
    const [ teacherName ] = args

    if (!teacherName) {
      ctx.user.state = UserState.AskingWeekTeacher
      // @ts-ignore
      await ctx.user.save()

      await ctx.answerCbQuery()
      await ctx.editMessageReplyMarkup(Markup.inlineKeyboard([[]]).reply_markup)

      await ctx.reply('ü§®', {
        reply_markup: keyboards[ctx.user.state as UserState].resize().reply_markup
      })

      await ctx.editMessageText('üßÑ –ù–∞–ø–∏—à–∏ –∏–Ω–∏—Ü–∏–∞–ª—ã –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –∏–ª–∏ –µ–≥–æ —á–∞—Å—Ç—å\n\n–û–±—ã—á–Ω–æ –æ–Ω–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –§–∞–º–∏–ª–∏—è –ò. –û.')
    } else {
      const weekStart = getWeekStart(new Date())
      const weekEnd = new Date(weekStart)
      weekEnd.setDate(weekEnd.getDate() + 7)

      const lessons = await keeper.getLessons({
        teachers: [ teacherName ],
        from: weekStart,
        before: weekEnd
      })

      if (!lessons.length) {
        await ctx.answerCbQuery()
        await ctx.editMessageReplyMarkup(Markup.inlineKeyboard([[]]).reply_markup)
        await ctx.editMessageText(`ü™§ –ö–∞–∂–µ—Ç—Å—è –∫—Ç–æ-—Ç–æ –∫–∞–π—Ñ—É–µ—Ç –Ω–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ`)
        return
      }

      await ctx.answerCbQuery()

      const groups = await parser.getGroups()

      await ctx.editMessageText([
        `–†–∞—Å–ø–∏–∞–Ω–∏—è –Ω–∞ –Ω–µ–¥–µ–ª—é —É ${teacherName}`,
        lessonsToMessage(lessons, groups)
      ].join('\n'))
    }
  } else if (command === 'group_week') {
    const [ groupId ] = args

    if (!groupId) {
      ctx.user.state = UserState.AskingWeekGroup
      // @ts-ignore
      await ctx.user.save()

      await ctx.answerCbQuery()
      await ctx.editMessageReplyMarkup(Markup.inlineKeyboard([[]]).reply_markup)

      await ctx.reply('ü§®', {
        reply_markup: keyboards[ctx.user.state as UserState].resize().reply_markup
      })

      await ctx.editMessageText('ü•ï –ù–∞–ø–∏—à–∏ –Ω–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è')
    } else {
      let group: Group
      try {
        group = await parser.getGroup(groupId)
      } catch (e) {
        await ctx.answerCbQuery()
        await ctx.editMessageReplyMarkup(Markup.inlineKeyboard([[]]).reply_markup)
        await ctx.editMessageText(
          (e as Error).message === 'Group not found'
            ? 'üò≠ –ì—Ä—É–ø–ø–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'
            : 'üì∏ –ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫–∞–∫–∞—è-—Ç–æ –æ—à–∏–±–∫–∞'
        )
        return
      }

      const weekStart = getWeekStart(new Date())
      const weekEnd = new Date(weekStart)
      weekEnd.setDate(weekEnd.getDate() + 7)

      const lessons = await keeper.getLessons({
        group: groupId,
        from: weekStart,
        before: weekEnd
      })

      if (!lessons.length) {
        await ctx.answerCbQuery()
        await ctx.editMessageText(`ü•• –†–∞—Å–ø–∏–∞–Ω–∏—è –Ω–∞ –Ω–µ–¥–µ–ª—é –¥–ª—è ${group.display} –Ω–µ—Ç—É`)
        return
      }
    
      await ctx.answerCbQuery()
      await ctx.editMessageText([
        `–†–∞—Å–ø–∏–∞–Ω–∏—è –Ω–∞ –Ω–µ–¥–µ–ª—é –¥–ª—è ${group.display}`,
        lessonsToMessage(lessons)
      ].join('\n'))
    }
  }
})

bot.on(message('text'), async (ctx) => {
  if (ctx.newUser) {
    await ctx.reply('ü§Ø –ß—Ç–æ-—Ç–æ —è —Ç–µ–±—è –Ω–µ –≤–∏–¥–∞–ª. –õ–∞–¥–Ω–æ, —Å–µ–π—á–∞—Å –æ—Ñ–æ—Ä–º–∏–º—Å—è. –ù–∞–ø–∏—à–∏ –Ω–æ–º–µ—Ä —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã, —á—Ç–æ–±—ã —è –∑–Ω–∞–ª –∫–∞–∫–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ø–æ–ª—É—á–∞—Ç—å')
    return
  }

  if (ctx.user.state === UserState.AskingWeekGroup) {
    const groups = await parser.getGroups({ display: ctx.message.text })

    if (!groups.length) {
      await ctx.reply('ü•∫ –¢–∞–∫–æ–π –≥—Ä—É–ø–ø—ã –Ω–µ –Ω–∞—à–ª–æ—Å—å. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π –Ω–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã')
      return
    }

    ctx.user.state = UserState.MainMenu
    // @ts-ignore
    await ctx.user.save()

    ctx.reply('ü§®', {
      reply_markup: keyboards[ctx.user.state as UserState].resize().reply_markup
    })

    await ctx.reply('üçç –í—ã–±–µ—Ä–∏ –≥—Ä—É–ø–ø—É', {
      reply_markup: batchButtons(
        groups.map(g => Markup.button.callback(g.display, callbackIdBuild('group_week', [ g.id! ]))),
        3
      ).reply_markup
    })
  }

  if (ctx.user.state === UserState.AskingWeekTeacher) {
    const teachers: string[] = await keeper.getTeachers({ name: ctx.message.text })

    if (!teachers.length) {
      await ctx.reply('ü•∫ –¢–∞–∫–æ–≥–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –Ω–µ –Ω–∞—à–ª–æ—Å—å. –ü–æ–ø—Ä–æ–±—É–π –Ω–∞–ø–∏—Å–∞—Ç—å –ø–æ-–¥—Ä—É–≥–æ–º—É')
      return
    }

    ctx.user.state = UserState.MainMenu
    // @ts-ignore
    await ctx.user.save()

    ctx.reply('ü§®', {
      reply_markup: keyboards[ctx.user.state as UserState].resize().reply_markup
    })

    await ctx.reply('üçç –í—ã–±–µ—Ä–∏ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è', {
      reply_markup: batchButtons(
        teachers.map(t => Markup.button.callback(t, callbackIdBuild('teacher_week', [ t ]))),
        3
      ).reply_markup
    })
  }

  if (ctx.user.state === UserState.AskingGroup) {
    const groups = await parser.getGroups({ display: ctx.message.text })

    if (!groups.length) {
      await ctx.reply('ü©º –¢–∞–∫–∏—Ö –≥—Ä—É–ø–ø —è –Ω–µ –≤–∏–¥–∞–ª. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π –Ω–æ–º–µ—Ä')
      return
    }

    ctx.user.choosing_groups = groups.map(g => ({ id: g.id, display: g.display }))
    ctx.user.state = UserState.ChoosingGroup
    // @ts-ignore
    await ctx.user.save()

    await ctx.reply('üëû –í—ã–±–µ—Ä–∏ –≥—Ä—É–ø–ø—É', {
      reply_markup: batchButtons(
        ctx.user.choosing_groups
          .map(g => Markup.button.callback(g.display!, callbackIdBuild('select_group', [ g.id! ])))
      ).reply_markup
    })

    await ctx.reply('ü§®', {
      reply_markup: keyboards[ctx.user.state as UserState].resize().reply_markup
    })
  }
})

await bot.launch()